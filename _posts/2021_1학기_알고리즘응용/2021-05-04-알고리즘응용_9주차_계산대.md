---
######layout: post
author: 류건열
#title: Algorithm_Application_Assignment
---


+  9주차 과제 - 계산대(이진 탐색)
    

![image](https://user-images.githubusercontent.com/34560965/116914858-44839000-ac86-11eb-90ae-4027bdad4dca.png)
![image](https://user-images.githubusercontent.com/34560965/116914862-464d5380-ac86-11eb-94ba-2eef74510e1b.png)
 


- 사용 언어 : python

- 해결 날짜 : 2021-05-04

- 느낀점 및 해결 과정 : 

    - 이진 탐색을 위한 시작점과 끝점을 설정한다. 여기서 끝점은 최대 시간의 계산대에서 K명이 전부 계산한 경우이다.
    - 이진 탐색을 수행하며 mid시간 안에 있는 계산대 일 때만 계산한 사람의 수를 추가해준다.
    - 계산한 사람의 수가 계산이 끝났을 때 계산한 사람의 수가 모자란 경우 더 많은 시간을 부여하고(오른쪽 부분 탐색), 충분한 경우 더 적은 시간을 부여한다(왼쪽 부분 탐색).




    - 시간 복잡도 : 

        - max : 전체를 한 번씩 탐색하므로 O(N)
        - 이진 탐색 내 for문 : O(T) ( T = 리스트의 크기, 즉 계산대의 수 ), 이진 탐색 : O(logN)
        - 따라서 O(N + T*logN) = O(TlogN) 의 시간 복잡도를 갖는다.




        

    - 코드	

    ```python
    # N = 계산대의 수, K = 고객의 수
    N, K = map(int, input().split())
    # 계산대 별 계산에 걸리는 시간
    T = list(map(int, input().split()))

    # 이진 탐색을 위한 시작점과 끝점
    # 끝점은 최대 시간의 계산대에서 K명이 전부 계산한 경우
    start = 0
    end = max(T)*K

    # 이진 탐색 수행
    result = 0
    while start <= end:
        total = 0
        count = 0
        mid = (start + end) // 2
        for x in T:
            # mid 시간안에 있는 계산대에서만 계산 가능
            if x <= mid:
                # 계산한 사람의 수 계산
                count += mid // x
        # 계산한 사람의 수가 모자란 경우 더 많은 시간을 부여(오른쪽 부분 탐색)
        if count < K:
            start = mid + 1
        # 계산한 사람의 수가 충분한 경우 더 적은 시간을 부여(왼쪽 부분 탐색)
        else:
            result = mid  # 최소 시간을 찾는 것 이므로 저장해놓음
            end = mid - 1

    print(result)
    ```
