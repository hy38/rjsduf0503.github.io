I"<ul>
  <li>오늘의 계획
    <ul>
      <li>실리콘밸리 인턴쉽 리액트 작업하기</li>
      <li>프로그래머스/백준 사이트에서 알고리즘 문제 풀이(그래프)</li>
    </ul>
  </li>
</ul>

<hr />
<ul>
  <li>오늘의 회고
    <ul>
      <li>react 작업
        <ul>
          <li>오늘 완료하지 못한 login 작업을 하였다.</li>
        </ul>
      </li>
      <li>그래프 문제 풀이 : 가장 먼 노드(프로그래머스 LEVEL 3)
  <img src="https://user-images.githubusercontent.com/34560965/125789003-0a13cc33-c27c-4e4a-bef0-0a17ff7b9010.png" alt="image" />
  <img src="https://user-images.githubusercontent.com/34560965/125789026-843fd90d-b885-44a4-ac33-0958be9e127e.png" alt="image" />
  <img src="https://user-images.githubusercontent.com/34560965/125789040-04d59a54-2f05-45e8-b3cc-349239174c40.png" alt="image" />
        <ul>
          <li>해결 방법 : 처음에 보자마자 다익스트라를 사용하면 되겠다 싶었는데 더 간단하게 구현할 수 있을 것 같아 방향을 바꿨다.</li>
          <li>graph에 edge 속 간선을 양방향으로 이어주고, 시작 노드로부터 거리가 1인 노드를 q에 추가하였다.</li>
          <li>그 후 q가 비어 있지 않은 동안 반복하며 next 노드까지의 거리(length)가 INF로 초기화된 distance 보다 더 짧다면 갱신 후 그 다음 노드들을 q에 append하는 방식을 통해 문제를 해결하였다.</li>
          <li>이 때 distance 배열의 0번째 인덱스에는 INF 값이 들어 있으므로 while문을 돌며 갱신한 maxDistance의 개수를 세는 방식을 활용해 최대 거리 노드의 개수를 구하였다.</li>
        </ul>
      </li>
      <li>
        <p>코드 :</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>  ```python
  from collections import deque
  INF = int(1e9)

  def solution(n, edge):
      answer = 0
      maxDistance = 0
      graph = [[] for i in range(n+1)]
      distance = [INF] * (n + 1)
      distance[1] = 0
            
      # 간선 이어주기
      for i in edge:
          f, t = i
          graph[f].append(t)
          graph[t].append(f)
            
      q = deque()

      # 시작 노드로부터 거리가 1인 노드를 큐에 추가
      for i in graph[1]:
          q.append([i, 1])
            
      while q:
          # next 노드까지의 거리가 length
          next, length = q.popleft()
          # 다음 노드까지의 거리가 더 짧다면 갱신 후 q에 append 
          if distance[next] &gt; length:
              maxDistance = max(maxDistance, length)
              distance[next] = length
              for n in graph[next]:
                  q.append([n, length + 1])

      # 1번 노드로부터 최대 거리인 노드들의 개수
      answer = distance.count(maxDistance)
            
      return answer
  ```
</pre></td></tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>
:ET