I"<ul>
  <li>오늘의 계획
    <ul>
      <li>
        <p>대표적인 관계형 DB인 MYSQL 강의 듣기</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>  - 섹션 3 - MySQL 테이블의 생성	 
</pre></td></tr></tbody></table></code></pre></div>        </div>
      </li>
      <li>
        <p>DFS/BFS 알고리즘 공부 및 문제 풀이</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>  - 프로그래머스 문제 풀이 
</pre></td></tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li>오늘의 회고
<img src="https://user-images.githubusercontent.com/34560965/105172235-a77f6a00-5b62-11eb-94d2-a63eec36b361.png" alt="image" />
    <ul>
      <li>인프런 DataBase 강의 수강
        <ul>
          <li>
            <p>CREATE TABLE name 으로 테이블 생성 가능하다. 괄호안의 숫자는 몇 글자까지인지, NOT NULL은 값이 꼭 필요하기 때문에, AUTO_INCREMENT는 중복을 피하기 위해 행의 추가 시 자동으로 1씩 증가, PRIMARY KEY는 중복을 방지한다.    <br />
 <img src="https://user-images.githubusercontent.com/34560965/105170434-45be0080-5b60-11eb-96a8-cfb07a95c869.png" alt="image" /></p>
          </li>
          <li>
            <p>테이블을 생성하고, 그 테이블이 제대로 만들어 졌는지 확인했다.   <br />
 <img src="https://user-images.githubusercontent.com/34560965/105171663-dd701e80-5b61-11eb-9119-9ff0438e8b3c.png" alt="image" /></p>
          </li>
        </ul>
      </li>
      <li>DFS/BFS 알고리즘 문제 : 프로그래머스 LEVEL 3(네트워크)
        <ul>
          <li>DFS/BFS 알고리즘 : DFS는 깊이 우선 탐색으로, 루트 노드 혹은 임의의 노드로부터 시작해 다음 분기로 넘어가기 전 현재 분기를 완벽하게 탐색하는 방법이고, BFS는 루트 노드 혹은 임의의 노드로부터 시작해 인접한 노드를 먼저 탐색하는 방법이다.</li>
        </ul>

        <p><img src="https://user-images.githubusercontent.com/34560965/105178409-56c03f00-5b6b-11eb-93d3-d80cfd82626e.png" alt="image" />
 	<strong>-해결 방법</strong> :</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>  - visited라는 방문하였는지의 여부를 나타내는 배열을 만들어 반복문으로 computers vector를 돌며 아직 방문하지 않았고, dfs한 결과가 참일 때 answer의 값을 증가시키는 방법으로 문제를 해결하였다. dfs에서는 이미 방문한 컴퓨터라면 false를 반환하고, 방문하지 않았다면 방문했다고 변경 후 다른 컴퓨터와 연결되어 있을 때 재귀 호출로 dfs를 다시 수행하였다. dfs를 완료하면 true를 반환하도록 하였다.
</pre></td></tr></tbody></table></code></pre></div>        </div>

        <ul>
          <li>코드</li>
        </ul>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td> --><td class="rouge-code"><pre>  #include &lt;string&gt;
  #include &lt;vector&gt;

  using namespace std;
  bool visited[200];

  bool dfs(int n, vector&lt;vector&lt;int&gt;&gt; computers){
      if(visited[n]) return false; //이미 방문한 컴퓨터라면 false 반환
      visited[n] = true; //방문했다고 변경
      for(int i = 0; i&lt; computers.size(); i++){
          if(computers[n][i] == 1 &amp;&amp; n!=i){ //연결되어 있을 때 dfs 반복
              dfs(i, computers);
          }
      }
      return true; //dfs 완료되면 true 반환
  }

  int solution(int n, vector&lt;vector&lt;int&gt;&gt; computers) {
      int answer = 0;
            
      for(int i = 0; i&lt;n; i++){
          if(!visited[i] &amp;&amp; dfs(i, computers)){ //아직 방문하지 않았고, dfs의 결과가 참일 때
              answer++; //answer 증가
          }
      }
            
      return answer;
  }
</pre></td></tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>
:ET