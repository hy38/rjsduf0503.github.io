I" <ul>
  <li>12주차 과제 - 행렬 바꾸기</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/34560965/120118583-4893c680-c1ce-11eb-8579-e7de4707b9a6.png" alt="image" />
<img src="https://user-images.githubusercontent.com/34560965/120118585-4af62080-c1ce-11eb-82cf-0c7762161e87.png" alt="image" />
<img src="https://user-images.githubusercontent.com/34560965/120118588-4c274d80-c1ce-11eb-8e8d-9a9587a612d2.png" alt="image" /></p>

<ul>
  <li>
    <p>사용 언어 : python</p>
  </li>
  <li>
    <p>해결 날짜 : 2021-05-31</p>
  </li>
  <li>
    <p>느낀점 및 해결 과정 :</p>

    <ul>
      <li>순위를 저장할 순위 행렬을 전부 1로 초기화 시켜준다.</li>
      <li>입력한 행렬을 돌며 인덱스와 같이 heapq(최소힙)에 삽입한다.</li>
      <li>
        <p>change_matrix 함수를 통해 입력한 행렬을 각 행과 열에 따른 순위 행렬로 변경한다. 큐가 비어 있지 않은 동안, 큐에서 우선 순위가 가장 높은 값을 pop하여 그 인덱스가 있는 행과 열을 돌며 현재 인덱스의 값보다 크고, 현재 인덱스의 우선 순위보다 작다면 우선 순위를 현재 인덱스의 우선 순위 + 1로 수정한다.</p>
      </li>
      <li>
        <p>시간 복잡도 :</p>

        <ul>
          <li>최소힙에 삽입 : O(MN) (M = 행의 개수, N = 열의 개수)</li>
          <li>change_matrix : O(MN*(M+N)) (M = 행의 개수, N = 열의 개수)</li>
          <li>따라서 O(MN + MN*(M+N)) = O(K2+2K3) = O(K3) 의 시간 복잡도를 갖는다. (K = 행 또는 열의 개수)</li>
        </ul>
      </li>
      <li>코드</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> --><td class="rouge-code"><pre>  <span class="kn">import</span> <span class="nn">heapq</span>

  <span class="c1"># M = 행의 개수, N = 열의 개수, matrix = 행렬, priority = 순위 행렬
</span>  <span class="n">M</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
  <span class="n">matrix</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)]</span>
  <span class="n">priority</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">N</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)]</span>

  <span class="c1"># 입력한 행렬을 돌며 인덱스와 같이 heapq(최소힙)에 삽입
</span>  <span class="n">hq</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
          <span class="n">heapq</span><span class="p">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">hq</span><span class="p">,</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>


  <span class="c1"># 입력한 행렬을 각 행과 열에 따른 순위 행렬로 변경하는 함수
</span>  <span class="k">def</span> <span class="nf">change_matrix</span><span class="p">():</span>
      <span class="k">while</span> <span class="n">hq</span><span class="p">:</span> <span class="c1"># 큐가 비어 있지 않을 때 반복
</span>          <span class="n">val</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">hq</span><span class="p">)</span>
          <span class="n">prior</span> <span class="o">=</span> <span class="n">priority</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="c1"># 현재 우선 순위
</span>          <span class="c1"># 현재 인덱스의 행과 열을 돌며
</span>          <span class="c1"># 현재 인덱스의 값보다 크고, 현재 인덱스의 우선 순위보다 작다면
</span>          <span class="c1"># 우선 순위를 현재 인덱스의 우선 순위 + 1
</span>          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
              <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="ow">and</span> <span class="n">prior</span> <span class="o">&gt;=</span> <span class="n">priority</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]:</span>
                  <span class="n">priority</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span> <span class="o">+</span> <span class="mi">1</span>
          <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
              <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">prior</span> <span class="o">&gt;=</span> <span class="n">priority</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                  <span class="n">priority</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span> <span class="o">+</span> <span class="mi">1</span>


  <span class="n">change_matrix</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">priority</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
          <span class="k">print</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">' '</span><span class="p">)</span>
      <span class="k">print</span><span class="p">()</span>

</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>
:ET